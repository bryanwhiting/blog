/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LoggingNote
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/console-proxy.ts
var WINDOW_CONSOLE = window.console;
var ConsoleProxy = class {
  constructor(options) {
    const { app, logger } = options;
    this.app = app;
    this.logger = logger;
  }
  // Installing the console proxy object and the listener for uncaught errors
  setup() {
    const { logger } = this;
    const consoleProxy = new Proxy(
      window.console,
      {
        get: function(target, prop) {
          const property = target[prop];
          if (typeof property === "function") {
            return function(...args) {
              var _a, _b;
              const sender = (_b = (_a = new Error().stack) == null ? void 0 : _a.split("\n").at(2)) == null ? void 0 : _b.replace(/^.+\((.+?)\).*$/, "$1").replace("app://obsidian.md/", "");
              logger.log(prop, sender, ...args);
              return property.apply(target, args);
            };
          }
          return property;
        }
      }
    );
    window.console = consoleProxy;
    window.addEventListener("error", this.onWindowError);
  }
  // Removing the console proxy object and the listener for uncaught errors
  teardown() {
    window.console = WINDOW_CONSOLE;
    window.removeEventListener("error", this.onWindowError);
    console.info(this.logger.prefixMsg("Proxy removed"));
  }
  /**
   * Event handler for window errors. Adds a "fatal"-level log event to the log
   * event queue.
   *
   * @param event - The error event object.
   */
  onWindowError(event) {
    const { message, colno, lineno, filename } = event;
    const logMessage = `${message} (${filename}:${lineno}:${colno})`;
    this.logger.log("fatal", logMessage);
  }
};

// src/note-logger.ts
var import_obsidian = require("obsidian");

// src/device-helper.ts
function getDeviceName(app) {
  var _a, _b;
  const syncPlugin = (_b = (_a = app.internalPlugins) == null ? void 0 : _a.plugins["sync"]) == null ? void 0 : _b.instance;
  if (!syncPlugin) {
    return "Unknown device";
  }
  return syncPlugin.deviceName ? syncPlugin.deviceName : syncPlugin.getDefaultDeviceName();
}

// src/note-logger.ts
var NoteLogger = class {
  constructor(app) {
    this.PLUGIN_LOGGING_PREFIX = "Logstravaganza";
    this.logEventsQueue = [];
    /**
     * Debounced function that processes log events by appending them to the note
     * file.
     */
    this.processLogEvents = (0, import_obsidian.debounce)(
      () => {
        this.app.workspace.onLayoutReady(async () => {
          const { vault } = this.app;
          const note = await this.getNoteFile();
          const newLines = [];
          let logEvent;
          while (logEvent = this.logEventsQueue.shift()) {
            const { timestamp, level, sender, args } = logEvent;
            if (level === "_tableheader") {
              newLines.push(
                "",
                "",
                "| Timestamp | Originator | Level | Message |",
                "| --------- | ---------- | ----- | ------- |"
              );
              continue;
            }
            const logMsg = args.map((arg) => typeof arg === "string" ? arg : JSON.stringify(arg)).join(" ").replace("|", "\\|");
            newLines.push(
              `| ${timestamp.toISOString()} | ${sender} | ${level} | ${logMsg} |`
            );
          }
          await vault.process(note, (currentNoteContent) => {
            return currentNoteContent + newLines.join("\n") + "\n";
          });
        });
      },
      1e3
    );
    this.app = app;
    this.OUTPUT_FILENAME = `LOGGING-NOTE (${getDeviceName(app)}).md`;
  }
  /**
   * Adds log events with the specified level and arguments to the log event
   * array. This function triggers the processing function to write the log events
   * to the note file.
   *
   * @param level - The level of the log event.
   * @param sender - The sender of the log event (e.g., "plugin:whatever").
   * @param args - The arguments to be logged, optional.
   */
  log(level, sender, ...args) {
    const timestamp = new Date();
    this.logEventsQueue.push({ timestamp, level, sender, args });
    this.processLogEvents();
  }
  /**
   * Prefixes a message with the plugin logging prefix.
   * @param msg - The message to be prefixed.
   * @returns The prefixed message.
   */
  prefixMsg(msg) {
    return `[${this.PLUGIN_LOGGING_PREFIX}] ${msg}`;
  }
  /**
   * Retrieves the note file with the specified path or creates a new one if it
   * doesn't exist.
   *
   * @returns A `Promise` that resolves to a `TFile` representing the note file.
   */
  async getNoteFile() {
    const { vault } = this.app;
    const note = vault.getAbstractFileByPath(this.OUTPUT_FILENAME);
    if (note instanceof import_obsidian.TFile) {
      return note;
    } else {
      return await vault.create(this.OUTPUT_FILENAME, "");
    }
  }
};

// src/plugin-info.ts
var PLUGIN_INFO = {
  "pluginVersion": "1.2.0",
  "pluginReleasedAt": "2023-07-23T19:58:08+0200"
};

// src/main.ts
var LoggingNote = class extends import_obsidian2.Plugin {
  onload() {
    const name = "plugin:logstravaganza";
    this.logger = new NoteLogger(this.app);
    this.logger.log("_tableheader", name);
    this.cProxy = new ConsoleProxy({ app: this.app, logger: this.logger });
    this.cProxy.setup();
    this.logger.log(
      "info",
      name,
      this.logger.prefixMsg(`Proxy set up (v${PLUGIN_INFO.pluginVersion})`)
    );
  }
  onunload() {
    this.cProxy.teardown();
  }
};
