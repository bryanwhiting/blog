{
  "hash": "322243f80d1664bf90a5f19f95477cb5",
  "result": {
    "markdown": "---\ntitle: Semantic Versioning for Data Science Models\ndescription: |\n  Meaningful versioning for data science models and machine learning pipelines.\ndate: 2018-07-02\nauthor:\n  - name: Bryan Whiting\ncategories: \n  - data science\n  - machine learning\noutput:\n  distill::distill_article:\n    self_contained: false\n---\n\n\nIf you've ever wanted to tag your data science model, you've probably wondered how to version it. Which will it be: vx.4.1, v34.1231.51.21, or v91.x4.dev34? After reading about _semantic versioning_, I propose a method for versioning data science models.\n\n# Semantic Versioning for Software\n\nSemantic versioning [proposes the following](https://semver.org/):\n\n> Given a version number MAJOR.MINOR.PATCH, increment the:\n>\n> 1. MAJOR version when you make incompatible API changes,\n> 2. MINOR version when you add functionality in a backwards-compatible manner, and\n> 3. PATCH version when you make backwards-compatible bug fixes.\n>\n> Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\nWell, I don't build APIs right now, but I think there is a way to apply this to the ways in which my software _does_ change.\n\n# Semantic Versioning for Data Science Models\n\nI propose that data science models use BETWEEN.WITHIN.PROCESS versioning, incrementing the\n\n1. BETWEEN version when you have an incompatible data change or target variable change, which render your models incomparable to prior versions, the\n2. WITHIN version when you improve or enhance a model output, and the\n3. PROCESS version when you update a pipeline but it doesn't ultimately improve the model.\n\n(Where BETWEEN implies 'between model' and WITHIN for 'within model'.)\n\n## An Example\n\nI build data science models by building python packages and committing the code to GitHub. The python package contains all of the support files and a `main.py` file to run the pipeline from start to finish. The support files could contain either helpful loggers to tell me where the pipeline is breaking down, diagnostic tools such as an AUC-ROC plot, files to engineer features, or files to train different model types. So there are really these three things that could happen to my code at any time. It doesn't matter where those changes occur, or how many lines of code changed. What matters is what's happened to the model. Each time I get a pull request approved, I'll update the version number in my repo.\n\n### Changing BETWEEN\n\nIncrement the BETWEEN version for the following changes:\n\n- When the structure of your data changes\n- If your target variable changes (how you coded it, or data that produced the target changed)\n- The underlying population you're training on changes\n\nAssume I discovered that I had a bad join. The join change might have been a minor one, but it's now difficult to really compare the two models because my target was affected as a result. What I was predicting, even if slightly different, is now something different. If you ever feel like you're comparing apples to oranges when looking at an AUC-ROC curve, update the BETWEEN version.\n\nWith each BETWEEN change, there should be a clear communication in the release notes of why the model is inherently different from prior models. These changes should be less frequent. \n\n### Changing WITHIN\n\nIncrement the WITHIN number when the following happens:\n\n- Features are added\n- Data sources are added or updated. (You might have several data sources today that help contribute to the target. But adding a data source might just mean adding new features. If you add data in such a way that it changes what you're ultimately modeling, update the BETWEEN version.)\n- New modeling types are added. (You might be using a logistic regression, but add a mo)\n\nSo if I added files that allowed me to train different model types, or added files that engineered new features, I'd incrememnt the WITHIN version. In my mind, this shouldn't be a _count_ of features you include, but should just be incremented every time you do something that affects the model performance.\n\nAt any time, you might what to view different subsets of features and their effect on the model. So, you might not change the number of features, but add some functionality into your pipeline that now produces three different models in each run. I would increment the WITHIN version number in that case.\n\nRemember, the goal of this type of versioning is to show generally what's changed in your pipeline.\n\n### Changing PROCESS\n\nIncrement the PROCESS version when the following happens:\n\n- A minor bug is fixed (unless this updates BETWEEN or WITHIN)\n- Enhance a logger or aspect of the pipeline\n- Add a diagnostic plot or table\n\nBasically, any time you add something that doesn't ultimately affect the performance of the model, you should update the PROCESS version. Your changes might improve the flow of your code and make you a much happier developer, but if it doesn't improve the model, then the key priority of your code hasn't improved. \n\n# Final Thoughts\n\nUltimately, data science semantic versioning can help communicate to team members what has fundamentally changed between software versions. Easily, a manager, colleague, or model governance officer could see the following version numbers and be able to know generally what's changed:\n\n1. `0.0.1`: Process improvement\n2. `0.1.0`: Model improvement\n3. `0.2.0`: Model improvement\n4. `1.0.0`: Model change\n5. `1.1.0`: Model improvement\n6. `1.1.1`: Process improvement\n\nSo what changed?\n\n1. `0.0.1`: Setting up the code base, but no model or features yet\n2. `0.1.0`: Finished a model, or added some features\n3. `0.2.0`: Added some features\n4. `1.0.0`: Discovered a bug in the target variable, something was miscoded. What is being predicted now changes (but you still have all the old features!)\n5. `1.1.0`: Added some new features\n6. `1.1.1`: Added a new plot to assess the financial impact of the model, but model doesn't inherently change.\n\nThis type of versioning also ultimately encourages a more disciplined workflow. Each sets of commit should be focused on one task alone. Because every time you update a version number, numbers to the right should refresh to zero. That's how the theory goes, at least. \n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}